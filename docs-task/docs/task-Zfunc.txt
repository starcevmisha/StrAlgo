Как вам известно, с помощью z-функции можно искать все вхождения строки w в t за оптимальное время O(|w| + |t|): надо просто посчитать z-функцию z[0..|w|+|t|] для строки w$t, где $ - это специальный нигде более не встречающийся символ. Этот алгоритм использует O(|w| + |t|) памяти и из-за такой прожорливости был нами забракован. Но если внимательно посмотреть на процесс построения z, можно заметите, что при вычислении значения z[i] реально используются только первые |w| значений z-функции - z[0..|w|-1] - а это в точности z-функция строки w!

В этой задаче вам надо разработать алгоритм поиска w в t, который из дополнительной памяти использует только z-функцию стоки w. Такой алгоритм хоть и оптимален, но всё равно сильно проигрывает Бойеру-Муру на практике. Зато с его помощью можно решить за O(|w| + |t|) следующую более сложную задачу: для каждого непустого префикса w[0..i] строки w надо посчитать число вхождений w[0..i] в t.

Пример. w = ababaaa, t = ababababaabbba
Префикс a строки w имеет 7 вхождений в t, ab - 5, aba - 4, abab - 3, ababa - 3, ababaa - 1, ababaaa - 0.

В файле Matcher.cs вам надо дописать функцию CountPrefixMatches так, чтобы она 1) работала за O(|pattern| + |text|) времени, 2) использовала только массив z[0..|pattern|-1], выходной массив prefixMatchCount[0..|pattern|-1] и может ещё O(1) памяти, 3) возвращала число вхождений каждого непустого префикса pattern в text в массиве prefixMatchCount. Например, для примера выше prefixMatchCount = {7, 5, 4, 3, 3, 1, 0}.

Вам в помощь дана реализация z-функции Zfunction, которую можно адаптировать для вашего решения, а также наивный метод вычисления prefixMatchCount и простой рандомизированный тест, по которым можно проверять корректность решения.

TEST