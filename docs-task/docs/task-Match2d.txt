В этой задаче вам нужно реализовать поиск двумерной подматрицы в матрице. Другими словами, дана матрица w[0..p-1][0..q-1], элементы которой суть символы некоторого алфавита {0,1,...s-1}, и надо найти все вхождения w в матрицу t[0..m-1][0..n-1], то есть найти все такие пары (i,j), что t[i..i+p-1][j..j+q-1] = w. Алгоритм должен работать за O((pq + mn)log s) и может в процессе работы использовать O(mn) памяти.
Пример: TEST
w = a b a b    t = a a b a b a x
    a b c d        c a b c d c x
    a b a b        a a b a b a b
                   x a b a b c d
                   x x x a b a b
Матрица w имеет два вхождения в t: в позициях (0,1) и (2, 3).
Ещё один интересный пример - когда w и t целиком состоят из одних букв a. В этом случае, при p <= m и q <= n, ваш алгоритм должен находить все (m-p+1)(n-q+1) вхождений w в t за O(mn).

Ваша задача - дописать функцию PatternMatches и класс AhoCorasick (класс можно менять по своему усмотрению). Вам в помощь дана наивная реализация NaivePatternMatches и простой рандомизированный тест, по которым можно проверять корректность решения.

Подсказка: посмотрите на t как на строку t[0][0..n-1] $ t[1][0..n-1] $ ... $ t[m-1][0..n-1], где $ - это спецсимвол, и воспользуйтесь алгоритмом Ахо-Корасик. Не забудьте про пример со всеми буквами a!
