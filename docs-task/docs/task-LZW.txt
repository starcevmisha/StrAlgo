Алгоритм Лемпеля–Зива–Велча – LZW – это относительно простой, но эффективный метод сжатия данных без потерь. Он является основой сжатия в GIF, TIFF и во многих других форматах. Входные данные алгоритма представляют собой строку t[0..|t|-1] над алфавитом {0, 1, ..., 255} (то есть символы – это байты). LZW читает строку слева направо, поддерживая при этом некоторый набор строк D и кодируя прочитанное. Изначально D содержит ровно 256 односимвольных строк. Каждой строке w в D присвоен код - id(w); односимвольным строкам присвоены соответствующие коды от 0 до 255. LZW жадно ищет в ещё не обработанной части t самый длинный префикс w, который содержится в D, и выдаёт в выходной файл код w - то есть id(w); затем LZW добавляет в набор D строку wa, где a - это символ, который следует за w, и строке wa присваивается следующий по порядку код. Более формально, алгоритм можно представить следующим псевдокодом:

d = 0;	//счётчик кодов для новых строк в D
for(c = 0; c < 256; c++) {
	D = D + {c};	//изначально D содержит все односимвольные строки
	id(c) = d++;	//каждой строке в D присвоен идентификатор id
}
for (i = 0; i < |t|;) {
	пусть w - это самый длинный префикс строки t[i..|t|-1], содержащийся в D 
	вывести id(w) в выходной файл (кодирование обсуждается ниже)
	if (i + |w| < |t|) {
		a = t[i + |w|];
		D = D + {wa};
		id(wa) = d++;
	}
	i += |w|;
}

Пример:
Пусть t = abababaabaabab.
Удобнее всего представлять себе, что LZW разбивает строку t на подстроки w, каждую из которых затем кодирует одним числом. В данном случае имеем следующее разбиение и соответствующие коды (ASCII коды a и b - 97 и 98):
a  b  ab  aba abaa ba  b
97 98 256 258 259  257 98
В процессе работы LZW последовательно добавляет в D строки ab, ba, aba, abaa, abaab, bab с кодами 256, 257, ..., 261, соответственно, сразу после вывода кодов для a, b, ab, aba, abaa, ba.

1.
Для записи id(w) в файл будем использовать ceil(log2(d)) битов - как раз столько битов нужно, чтобы представить число от 0 до d-1. Ваша первая задача - написать функцию DataToLZW, которая по данному входному массиву байтов byte[] data получает последовательность чисел id(w), используя O(|data| log s) времени и O(256 + z) памяти помимо памяти для data, где s - это размер алфавита data (s <= 256), а z - это число полученных чисел id(w). Функция Compress, кодирующая эти числа, написана за вас. (Формально, 256 + s = O(1), но чтобы учитывать существенность константы 256 для производительности, в этой задаче удобно _неформально_ полагать, что 256 и s не константы.) Для тестирования убедитесь, что Compress с помощью вашей реализации DataToLZW сжимает файлы-примеры "program.cs", "lotr.txt", "img.bmp" до, соответственно, 472, 151744, 42090 байтов.

2.
Это сразу не очевидно, но оказывается, по массиву чисел lzw = DataToLZW(data) можно однозначно восстановить исходную последовательность data. Ваша вторая задача - написать функцию LZWtoData, которая делает как раз это за O(|data| log s) времени. Подсказка: для этого нужно "эмулировать" алгоритм сжатия DataToLZW с помощью последовательности lzw. Но надо учесть один нюанс: когда очередной код lzw[j] соответствует строке w из D, возникшей на предыдущем шаге, последний символ w обязательно равен первому - в примере выше этот случай возникнет при чтении кода 258 для aba и чтении кода 259 для abaa (если данной нюанс вам непонятен - начните реализовывать LZWtoData и увидите проблему).
